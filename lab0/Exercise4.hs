import Data.List
import Data.Char
import Test.QuickCheck

-- Gets reversal of a natural number 
reversal :: Integer -> Integer
reversal = read . reverse . show

{-
Finds prime by creating a list of all numbers that are evenly divisible by i.
If a the number is prime, the only number in that list should be 1, reuslting 
in a list of length 1.

Time spent: 60 minutes
-}
findPrime :: Integer -> Bool
findPrime i
    | i < 2 = False
    | otherwise =
        let len = length [k | k <- [1..floor $ sqrt $ fromIntegral i], mod i k == 0]
        in len == 1

reversibleStream :: [Integer]
reversibleStream =
    [k | k <- [0..10000], findPrime k && findPrime (reversal k)]

-- Prime membership
{-
Checks if the reversibleStream function generates only prime numbers by generating a list of 
all prime numbers from 0 - 10000 and making sure that every number generated by reversibleStream
is in the prime number list 
-}
primeMembership :: [Integer] -> Bool
primeMembership i =
    let primeList = [j | j <- [1..10000], findPrime j]
    in all (`elem` primeList) i -- checks that every element in list i is in primeList, in other words a subset

-- Unique values 
uniqueValues :: [Integer] -> Bool
uniqueValues [] = True
uniqueValues (x:xs)
    | x `notElem` xs = uniqueValues xs
    | otherwise = False

-- Check Maximum
checkMax :: [Integer] -> Bool
checkMax i =
    maximum i < 10000



main :: IO()
main = do
    let primeResult = primeMembership reversibleStream
    print primeResult

    let uniqueResult = uniqueValues reversibleStream
    print uniqueResult

    let maxResult = checkMax reversibleStream
    print maxResult



